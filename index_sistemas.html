<!DOCTYPE html>
<html lang="es">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Paso 2: Organigrama Básico con Balkan y API</title>
    <script src="orgchart.js"></script>
    <style>
      /* Estilos básicos (igual que antes) */
      html,
      body {
        margin: 0;
        padding: 0;
        width: 100%;
        height: 100%;
        overflow: hidden;
        font-family: Arial, sans-serif;
      }
      #tree {
        width: 100%;
        height: 100%;
        background-color: #f8f8f8;
      }
      #status-message {
        position: absolute;
        top: 10px;
        left: 10px;
        background: rgba(255, 255, 255, 0.8);
        padding: 10px;
        border-radius: 4px;
        z-index: 10;
        font-size: 0.9em;
      }
      #error-message {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        color: red;
        background: #ffebeb;
        padding: 20px;
        border: 1px solid red;
        border-radius: 5px;
        text-align: center;
        max-width: 80%;
        z-index: 100;
        display: none;
      }
      /* Estilos simples para la tarjeta */
      .boc-node .boc-img-0 {
        /* Estilo para la imagen en plantilla 'ana' */
        width: 50px !important;
        height: 50px !important;
        border-radius: 50% !important;
        margin: auto 10px auto 10px !important;
      }
      .boc-node .boc-field-0 {
        /* Estilo para el nombre */
        font-size: 13px;
        font-weight: bold;
        max-width: 140px;
        text-overflow: ellipsis;
        overflow: hidden;
        white-space: nowrap;
      }
      .boc-node .boc-field-1 {
        /* Estilo para el puesto */
        font-size: 11px;
        color: #555;
        max-width: 140px;
        text-overflow: ellipsis;
        overflow: hidden;
        white-space: nowrap;
      }
      .boc-node.vacante .boc-rect {
        /* Estilo para vacantes */
        fill: #fafafa !important;
        stroke: #ccc !important;
        stroke-dasharray: 3, 3 !important;
      }
      .boc-node.vacante .boc-field-0 {
        /* Puesto centrado en vacantes */
        text-anchor: middle;
        font-style: italic;
        font-weight: bold;
        fill: #999;
      }
    </style>
  </head>
  <body>
    <div id="status-message">Cargando...</div>
    <div id="error-message"></div>
    <div id="tree"></div>

    <script>
      const statusDiv = document.getElementById("status-message");
      const errorDiv = document.getElementById("error-message");
      const treeDiv = document.getElementById("tree");
      let currentChart = null; // Referencia al gráfico

      // --- Función de Ayuda: Detectar y Romper Referencias Circulares ---
      // --- Función de Ayuda: Detectar y Romper Referencias Circulares (Versión 2) ---
      function sanitizeCircularReferences(nodes) {
        const nodeMap = new Map();
        nodes.forEach((node) => {
          if (node && node.id != null) {
            nodeMap.set(node.id, node);
          } else {
            console.warn(
              "Sanitizing V2: Omitiendo nodo inválido durante creación de mapa:",
              node
            );
          }
        });
        let loopsBroken = 0;

        console.log("Sanitizing V2: Iniciando sanitización de bucles..."); // Iteramos sobre una copia de las keys para evitar problemas si modificamos el mapa

        const nodeIds = Array.from(nodeMap.keys());

        for (const nodeId of nodeIds) {
          const startNode = nodeMap.get(nodeId); // Solo necesitamos revisar nodos que tienen un padre potencial
          if (!startNode || startNode.pid == null) continue;

          const pathVisited = new Set(); // Nodos visitados SOLO en esta traza ascendente
          let currentNode = startNode; // console.log(`Sanitizing V2: Trazando desde ${startNode.id}`); // Log opcional muy verboso

          while (currentNode && currentNode.pid != null) {
            const currentId = currentNode.id;
            const parentId = currentNode.pid; // 1. Verificar si ya visitamos este NODO (currentId) en ESTA traza específica

            if (pathVisited.has(currentId)) {
              console.warn(
                `¡Bucle detectado V2! Traza desde ${startNode.id} encontró un ciclo al volver a ${currentId}. Rompiendo enlace ${currentId} -> ${parentId}`
              );
              currentNode.pid = undefined; // Romper el enlace justo donde se detecta el ciclo
              loopsBroken++;
              break; // Detener esta traza
            }
            pathVisited.add(currentId); // Marcar este nodo como visitado en esta traza // 2. Verificar si el padre existe

            if (!nodeMap.has(parentId)) {
              console.warn(
                `Sanitizing V2: Nodo ${currentId} tiene un parentId inválido o faltante: ${parentId}. Tratando nodo ${currentId} como raíz.`
              );
              currentNode.pid = undefined; // Convertir en raíz
              break; // Detener esta traza
            } // Subir al padre

            currentNode = nodeMap.get(parentId); // Seguridad extra (no debería ocurrir si .has() funcionó)

            if (!currentNode) {
              console.error(
                "Sanitizing V2: Error inesperado al obtener el padre",
                parentId
              );
              break;
            }
          }
        }

        console.log(
          `Sanitizing V2: Sanitización completa. Se rompieron ${loopsBroken} bucles.`
        ); // Devolver los nodos modificados (ya no necesitamos el filtro final aquí)
        return Array.from(nodeMap.values());
      }

      // --- Función Principal: Cargar Datos y Renderizar Gráfico Básico ---
      async function loadAndRenderBasicChart(apiUrl) {
        statusDiv.innerText = "Llamando a la API...";
        errorDiv.style.display = "none";
        treeDiv.innerHTML = ""; // Limpiar área

        try {
          // 1. Llamar a la API
          console.log("Iniciando fetch a:", apiUrl);
          const response = await fetch(apiUrl);
          console.log("Respuesta recibida, status:", response.status);
          statusDiv.innerText = `API respondió (${response.status}). Procesando...`;

          if (!response.ok) {
            throw new Error(
              `Error HTTP ${response.status}: ${response.statusText}`
            );
          }

          const apiResponse = await response.json();
          console.log("Respuesta JSON recibida.", apiResponse);

          // 2. Extraer el Array de 'Persona'
          const flatApiData = Array.isArray(apiResponse?.Persona)
            ? apiResponse.Persona
            : null;

          if (!Array.isArray(flatApiData)) {
            console.error(
              "La propiedad 'Persona' no es un array:",
              apiResponse
            );
            throw new Error(
              "Formato inválido. No se encontró array en 'Persona'."
            );
          }

          if (flatApiData.length === 0) {
            statusDiv.innerText = "API OK, pero no hay datos.";
            return;
          }
          console.log(
            `Datos extraídos (${flatApiData.length}). Preprocesando y Transformando...`
          );
          statusDiv.innerText = `Datos recibidos (${flatApiData.length}). Procesando...`;

          // --- INICIO: Pre-cálculo del Mapa Posición -> ID Empleado ---
          const positionToEmployeeMap = new Map();
          flatApiData
            .filter(
              (emp) =>
                emp &&
                emp.codigoPosicion != null &&
                String(emp.codigoPosicion).trim() !== "00006" &&
                (emp.nombreDepartamento === "SISTEMAS" ||
                  emp.nombreDepartamento === "DIRECTORIO")
            ) // Filtrar nodos sin ID
            .forEach((emp) => {
              // Solo mapear si NO es vacante y tiene ambos códigos
              if (
                emp &&
                emp.vacante !== "1" &&
                emp.codigoPosicion &&
                emp.codigoEmpleado
              ) {
                const positionId = String(emp.codigoPosicion).trim();
                const employeeId = String(emp.codigoEmpleado).trim();
                if (positionToEmployeeMap.has(positionId)) {
                  // Advertencia si una posición tiene múltiples empleados asignados (no vacantes)
                  // Nos quedamos con el primero encontrado en este caso simple.
                  // Podrías necesitar una lógica más compleja si esto es común.
                  console.warn(
                    `Advertencia: La posición ${positionId} está asignada a más de un empleado. Usando empleado ${positionToEmployeeMap.get(
                      positionId
                    )}.`
                  );
                } else {
                  positionToEmployeeMap.set(positionId, employeeId);
                }
              }
            });
          console.log(
            `Mapa Posición->Empleado creado con ${positionToEmployeeMap.size} entradas.`
          );
          // --- FIN: Pre-cálculo ---

          // 3. Transformación BÁSICA (id, pid, campos para mostrar)
          let balkanNodes = flatApiData
            .filter(
              (emp) =>
                emp &&
                emp.codigoPosicion != null &&
                String(emp.codigoPosicion).trim() !== "00006" &&
                (emp.nombreDepartamento === "SISTEMAS" ||
                  emp.nombreDepartamento === "DIRECTORIO")
            ) // Filtrar nodos sin ID
            .map((emp) => {
              //console.log(emp);
              const id = String(emp.codigoEmpleado).trim();
              //const id = String(emp.codigoPosicion).trim();
              let pid = emp.codigoPosicionReporta
                ? String(emp.codigoPosicionReporta).trim()
                : undefined;

              const managerPositionId = emp.codigoPosicionReporta
                ? String(emp.codigoPosicionReporta).trim()
                : null;
              // --- CAMBIO: Buscar el ID del empleado jefe usando el mapa ---
              if (managerPositionId && managerPositionId !== "0") {
                pid = positionToEmployeeMap.get(managerPositionId); // pid ahora es codigoEmpleado del jefe
                // Si no se encuentra (puesto jefe vacante o no existe), pid se quedará undefined (raíz)
                if (!pid) {
                  // console.log(`Nodo ${id} reporta a posición ${managerPositionId} pero no se encontró empleado (¿vacante?). Se tratará como raíz/huérfano.`);
                }
                // Evitar auto-referencia por empleado ID (poco probable pero seguro)
                if (pid === id) {
                  console.warn(
                    `Nodo ${id} intenta reportarse a sí mismo (empleado ID). Tratando como raíz.`
                  );
                  pid = undefined;
                }
              }

              // --- SOLUCIÓN AQUÍ ---
              // Si el pid es nulo, vacío, igual al id, o es '0' o '00000', es un nodo raíz.
              /* if (
                !pid ||
                pid === id ||
                pid === "0" ||
                pid === "00006" ||
                pid === ""
              ) {
                pid = undefined;
              } */

              let nodeData = {
                id,
                pid,
                tags: [],
                nivel: emp.nivelJerarquico ? parseInt(emp.nivelJerarquico) : 99,
              }; // Incluir tags para vacante

              if (emp.vacante === "1") {
                nodeData.tags.push("vacante");
                nodeData.puesto = emp.puesto || "Puesto Vacante"; // Solo necesitamos puesto para vacante
              } else {
                nodeData.nombre = `${emp.nombre || "N/A"} ${
                  emp.apellido || ""
                }`.trim();
                nodeData.puesto = emp.puesto || "Puesto no definido";
                nodeData.img =
                  emp.foto ||
                  "https://via.placeholder.com/60/cccccc/ffffff?text=N/A";
                nodeData.departamento = emp.nombreDepartamento || "N/D";

                // --- AÑADIR TAGS DE NIVEL ---
                if (nodeData.nivel <= 7) {
                  // Solo añadir tags a niveles conocidos
                  nodeData.tags.push(`nivel-${nodeData.nivel}`);
                }
                // --- FIN ---
              }
              return nodeData;
            });

          // --- LIMITAR A 200 REGISTROS ---
          /*const DEBUG_LIMIT = 200; // Set limit to 200
            if (DEBUG_LIMIT > 0 && balkanNodes.length > DEBUG_LIMIT) {
                console.log(`Limitando datos de ${balkanNodes.length} a ${DEBUG_LIMIT} para depuración.`);
                balkanNodes = balkanNodes.slice(0, DEBUG_LIMIT); // Truncate the array
                // console.log(`Primeros ${DEBUG_LIMIT} registros RAW:`, JSON.stringify(flatApiData, null, 2)); // Optional: Log the limited data
            } */

          console.log(`Transformación completa (${balkanNodes.length} nodos).`);
          statusDiv.innerText = `Datos transformados. Renderizando gráfico...`;

          // --- PASO DE SANITIZACIÓN AÑADIDO ---
          const sanitizedNodes = sanitizeCircularReferences(balkanNodes); // --- FIN DEL PASO ---
          statusDiv.innerText = `Datos sanitizados. Renderizando gráfico...`;

          if (balkanNodes.length === 0) {
            throw new Error(
              "Ningún nodo válido quedó después de la transformación."
            );
          }
          console.log(sanitizedNodes.length);
          console.log(sanitizedNodes);

          // --- (Keep the dynamic 'force-horizontal' tagging logic for managers with many reports) ---
          // This ensures Seniors are arranged horizontally if there are many of them.
          const parentChildCount = new Map();
          sanitizedNodes.forEach((node) => {
            if (node.pid)
              parentChildCount.set(
                node.pid,
                (parentChildCount.get(node.pid) || 0) + 1
              );
          });
          const HORIZONTAL_THRESHOLD = 2;
          sanitizedNodes.forEach((node) => {
            if (
              parentChildCount.has(node.id) &&
              parentChildCount.get(node.id) > HORIZONTAL_THRESHOLD
            ) {
              if (!node.tags.includes("force-horizontal")) {
                node.tags.push("force-horizontal");
              }
            }
          });
          // --- End dynamic tagging ---

          // 4. Configuración BÁSICA de Balkan
          // Definir plantilla simple para vacantes (solo muestra el puesto)
          OrgChart.templates.vacanteSimple = Object.assign(
            {},
            OrgChart.templates.ana
          );
          OrgChart.templates.vacanteSimple.node =
            '<rect x="0" y="0" width="{w}" height="{h}" fill="#fafafa" stroke="#dddddd" rx="6" ry="6" stroke-dasharray="3 3"></rect>';
          OrgChart.templates.vacanteSimple.field_0 =
            '<text style="font-size: 12px; font-style: italic;" fill="#999999" x="{cw}" y="{ch}" text-anchor="middle">{val}</text>'; // Puesto centrado

          const chartConfig = {
            // Configuraciones básicas de layout e interacción
            mouseScrool: OrgChart.action.zoom,    // Zoom con scroll
            enableSearch: false,
            template: "olivia", // Usar plantilla 'ana' por defecto
            mode: 'dark',
            nodeExtent: { width: 220, height: 80 }, // Tamaño de tarjeta
            scaleInitial: OrgChart.match.boundary, // Ajustar al contenedor
            layout: OrgChart.normal, // Layout estándar
            nodeMenu: { details: { text: "Detalles" } }, // Menú simple
            padding: 20, // Margen
            nodes: sanitizedNodes,
            nodeBinding: {
              // Mapeo para plantilla 'ana'
              field_0: "nombre",
              field_1: "puesto",
              img_0: "img",
            },
            tags: {
              vacante: {
                // Aplicar plantilla simple a vacantes
                template: "vacanteSimple",
                nodeBinding: { field_0: "puesto" }, // Mapear 'puesto' al field_0 de la plantilla vacante
              },
              "force-horizontal": { subLayout: OrgChart.normal }, // Keep this
              // --- DEFINICIONES DE TAGS DE NIVEL ---
              "nivel-5": {
                // Senior - Posición Normal (valores de 'ana')
                template: "ana", // Redundante, pero claro
              },
              "nivel-6": {
                // Junior - Bajar un poco el texto
                template: "ana", // Basado en 'ana'
                // Sobrescribir las definiciones de los campos de texto
                field_0: `<text ${OrgChart.attr.width}="230" style="font-size: 18px;" fill="#ffffff" x="125" y="100" text-anchor="middle">{val}</text>`, // y=95 -> 100
                field_1: `<text ${OrgChart.attr.width}="130" ${OrgChart.attr.text_overflow}="multiline" style="font-size: 14px;" fill="#ffffff" x="230" y="35" text-anchor="end">{val}</text>`, // y=30 -> 35
              },
              "nivel-7": {
                // Asistente - Bajar más el texto
                template: "ana",
                field_0: `<text ${OrgChart.attr.width}="230" style="font-size: 18px;" fill="#ffffff" x="125" y="105" text-anchor="middle">{val}</text>`, // y=95 -> 105
                field_1: `<text ${OrgChart.attr.width}="130" ${OrgChart.attr.text_overflow}="multiline" style="font-size: 14px;" fill="#ffffff" x="230" y="40" text-anchor="end">{val}</text>`, // y=30 -> 40
              },
              // Puedes añadir más niveles si es necesario
              // --- FIN ---
            },
          };

          // 5. Renderizar el Gráfico
          console.log("Inicializando OrgChart...");
          currentChart = new OrgChart(treeDiv, chartConfig);
          console.log("Gráfico renderizado (básico).");
          statusDiv.style.display = "none"; // Ocultar mensaje de estado
        } catch (error) {
          console.error("ERROR DETALLADO:", error);
          statusDiv.innerText = "Error.";
          errorDiv.innerText = `Error: ${error.message}. Revisa la consola (F12).`;
          errorDiv.style.display = "block";
        }
      }

      // --- Llamada inicial ---
      document.addEventListener("DOMContentLoaded", () => {
        const apiUrl =
          "API_URL_AQUI";
        loadAndRenderBasicChart(apiUrl);
      });
    </script>
  </body>
</html>
